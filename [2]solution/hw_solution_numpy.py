
# coding: utf-8

# <p style="align: center;"><img align=center src="https://s8.hostingkartinok.com/uploads/images/2018/08/308b49fcfbc619d629fe4604bceb67ac.jpg" width=500 height=450/></p>
# 
# <h3 style="text-align: center;"><b>Физтех-Школа Прикладной математики и информатики (ФПМИ) МФТИ</b></h3>

# ---

# ## Домашнее задание 2: библиотека Numpy и линейная алгебра. Решение
# 

# In[2]:

import numpy as np
import random
import scipy.stats as sps


# ### Numpy

# ### Задание 1
# В первой задаче вам предлагается перемножить две квадратные матрицы двумя способами -- без использования пакета ***numpy*** и с ним.

# In[3]:

# Для генерации матриц используем фукнцию random -- она используется для генерации случайных объектов 
# функция sample создает случайную выборку. В качестве аргумента ей передается кортеж (i,j),  
# здесь i -- число строк, j -- число столбцов.
a = np.random.sample((100, 100))
b = np.random.sample((100, 100))
# выведите размерность (ранг) каждой матрицы с помощью функции ndim.
# Используйте функцию shape, что она вывела?
# ========
# Ваш код здесь
# ========
print(a)
print(b)


# In[ ]:




# In[ ]:




# In[ ]:




# In[4]:

def mult(a, b):
    # здесь напишите перемножение матриц без 
    # использования NumPy и выведите результат
    c = [[0 for _ in range(len(a))] for _ in range(len(b[0]))]
    for i in range(len(a)):
        for j in range(len(b)):
            for k in range(len(a[0])):
                c[i][j] += a[i][k] * b[k][j]
    return c


# In[5]:

def np_mult(a, b):
    # здесь напишите перемножение матриц с
    # использованием NumPy и выведите результат
    return a @ b


# In[6]:

get_ipython().run_cell_magic('time', '', '# засечем время работы функции без NumPy\nM1 = mult(a, b)')


# In[7]:

get_ipython().run_cell_magic('time', '', '# засечем время работы функции с NumPy\nM2 = np_mult(a, b)')


# In[8]:

np.abs(np.array(M1) - M2).sum()


# ### Задание 2
# Напишите функцию, которая по данной последовательности $\{A_i\}_{i=1}^n$ строит последовательность $S_n$, где $S_k = \frac{A_1 + ... + A_k}{k}$.  
# Аналогично -- с помощью библиотеки **NumPy** и без нее. Сравните скорость.

# In[9]:

# функция, решающая задачу с помощью NumPy
def sec_av(A):
    return np.cumsum(A) / np.arange(1, len(A)+1)


# In[10]:

# функция без NumPy
def stupid_sec_av(A):
    S = [sum(A[:i+1])/(i+1) for i in range(len(A))]
    return S


# In[11]:

# зададим некоторую последовательность и проверим ее на ваших функциях. 
# вторая функция должна работать ~ в 50 раз быстрее
A = sps.uniform.rvs(size=10**3) 

get_ipython().magic('time S1 = stupid_sec_av(A)')
get_ipython().magic('time S2 = sec_av(A)')
# проверим корректность (последовательности должны совпадать, т.е. разность равна 0):
np.abs(S1 - S2).sum()


# ### Задание 3
# 
# Пусть задан некоторый массив $X$. Надо построить новый массив, где все элементы с нечетными индексами требуется заменить на число $a$ (если оно не указано, то на 1). Все четные элементы исходного массива нужно возвести в куб и записать в обратном порядке относительно позиций этих элементов. Массив $X$ при этом должен остаться *без изменений*. В конце требуется слить массив X с преобразованным X и вывести в обратном порядке.  
# 
# Пример:  
# X = [100, 200, 300, 400, 500] -> [100, a, 300, a, 500] -> [500^3, a, 300^3, a, 100^3] -> склеиваем -> [100, 200, 300, 400, 500, 500^3, a, 300^3, a, 100^3]

# In[12]:

# функция, решающая задачу с помощью NumPy
def transformation(X, a=1):
    N = np.array(X[::-1])
    N[1::2] = a
    N[::2] = N[::2] ** 3
    return np.hstack((np.array(X) , N))


# In[13]:

# функция, решающая задачу  без NumPy
def stupid_transformation(X, a=1):
    N = X[::-1]
    N[1::2] = [a for _ in range(len(N[1::2]))]
    N[::2] = [x**3 for x in N[::2]]
    return X + N


# In[14]:

X = [i for i in range(10, 1000, 10)]
# здесь код должен быть эффективнее примерно в 20 раз. 
get_ipython().magic('time S1 = stupid_transformation(X)')
get_ipython().magic('time S2 = transformation(X)')
# проверим корректность:
np.abs(S1 - S2).sum()


# Почему методы ***numpy*** оказываются эффективнее (можно гуглить)?

# Что вы можете сказать о скорости вычислений в NumPy? Ответ обоснуйте.

# **Ответ:** Скорость вычислений вектоных и матричных операций в NumPy сильно превосходит скорость вычислений без него, по большей части потому, что функции numpy работаю с массивами данных одного типа (числовыми), это позволяет реализовать встроенные функции numpy на C/C++, что, конечно, делает numpy быстрее (функции, которые вызывает Numpy для работы с числовыми данными, сильно оптимизированы именно под эти задачи, а сам Python просто гоняет интерпретатор по циклу в таких операциях, что является чуть ли не самым большим замедлением в работе интерпретатора).

# ### Задание 4

# Вам подаются на вход два вектора `a` и `b` в трехмерном пространстве.Заполните их случайными числами. Реализуйте их скалярное произведение с помощью  `NumPy` и без. Засеките время работы, как это показано в заданиях выше.

# In[15]:

a = np.random.sample((1, 3))
a = list(a)[0]
b = np.random.sample((1, 3))
b = list(b)[0]
print(a, b)


# In[16]:

def stupid_scalar_product(a,b):
    return sum([x * y for (x, y) in zip(a, b)])


# In[17]:

def numpy_scalar_product(a,b):
    return a @ b


# In[18]:

get_ipython().magic('time product_1 = stupid_scalar_product(a,b)')
get_ipython().magic('time product_2 = numpy_scalar_product(a,b)')
# проверим корректность:
np.abs(product_1 - product_2).sum()


# ### Задание 5*

# Нужно написать матричное произведение БЕЗ циклов и БЕЗ символа @, БЕЗ `np.dot` и вообще БЕЗ какой-либо вспомогательной функции из `numpy`, то есть пользуясь только индексированием, взятем суммы по нужным осям и поэлементным произведенем (да, это возможно). Рекомендуем гуглить по запросу "NumPy broadcasting"

# In[19]:

def cool_matrix_product(A, B):
    # налейте чаю, удобно присядьте и просто осознайте это :)
    # (на самом деле просто распишите, что получается про numpy broadcasting)
    return (A[:,:, None] * B[None,:,:]).sum(axis=1)  


# In[20]:

A = np.random.sample((100, 100))
B = np.random.sample((100, 100))


# In[22]:

np.sum(A@B - cool_matrix_product(A, B), axis=0)


# (машинный ноль)
